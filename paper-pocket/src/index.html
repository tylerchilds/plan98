<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PaperPocket</title>
    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: black;
      }

      iframe {
        display: block;
        border: none;
        width: 100%;
        height: 100%;
        margin: auto;
      }
    </style>
  </head>
  <body>
    <hello-native></hello-native>
    <script> 
      self.state ||= {}
      const nodes = {}
      const CREATE_EVENT = 'create'

      const observableEvents = [CREATE_EVENT]

      function update(target, compositor) {
        const html = compositor(target)
        if(html) target.innerHTML =  html
      }

      function draw(link, compositor) {
        listen(CREATE_EVENT, link, (event) => {
          react(link, event.target, update.bind(null, event.target, compositor))
        })
      }

      function style(link, stylesheet) {
        const styles = `
          <style type="text/css" data-link="${link}">
            ${stylesheet.replaceAll('&', link)}
          </style>
        `;

        document.body.insertAdjacentHTML("beforeend", styles)
      }

      function learn(link) {
        return state[link] || {}
      }

      function teach(link, knowledge, nuance = (s, p) => ({...s,...p})) {
        const current = state[link] || {}
        state[link] = nuance(current, knowledge);
        notify(link)
      }

      function react(link, target, callback) {
        if(!nodes[link]) {
          nodes[link] ={}
        }

        nodes[link][target.id] = callback
        notify(link)
      }

      function notify(link) {
        if(nodes[link]) {
          Object.keys(nodes[link]).map(id => {
            nodes[link][id]()
          })
        }
      }

      function when(link1, eventName, link2, callback) {
        listen(eventName, `${link1} ${link2}`, callback)
      }

      window.module = function module(link, initialState = {}) {
        teach(link, initialState)

        return {
          link,
          learn: learn.bind(null, link),
          draw: draw.bind(null, link),
          style: style.bind(null, link),
          when: when.bind(null, link),
          teach: teach.bind(null, link),
        }
      }

      function subscribe(fun) {
        notifications[fun.toString] = fun
      }

      function unsubscribe(fun) {
        if(notifications[fun.toString]) {
          delete notifications[fun.toString]
        }
      }

      function listen(type, link, handler = () => null) {
        const callback = (event) => {
          if(
            event.target &&
            event.target.matches &&
            event.target.matches(link)
          ) {
            handler.call(null, event);
          }
        };

        document.addEventListener(type, callback, true);

        if(observableEvents.includes(type)) {
          observe(link);
        }

        return function unlisten() {
          if(type === CREATE_EVENT) {
            disregard(link);
          }

          document.removeEventListener(type, callback, true);
        }
      }

      let links = []

      function observe(link) {
        links = [...new Set([...links, link])];
        maybeCreateReactive([...document.querySelectorAll(link)])
      }

      function disregard(link) {
        const index = links.indexOf(link);
        if(index >= 0) {
          links = [
            ...links.slice(0, index),
            ...links.slice(index + 1)
          ];
        }
      }

      function maybeCreateReactive(targets) {
        targets
          .filter(x => !x.reactive)
          .forEach(dispatchCreate)
      }

      function getSubscribers({ target }) {
        if(links.length > 0)
          return [...target.querySelectorAll(links.join(', '))];
        else
          return []
      }

      function dispatchCreate(target) {
        if(!target.id) target.id = sufficientlyUniqueId()
        target.dispatchEvent(new Event(CREATE_EVENT))
        target.reactive = true
      }

      new MutationObserver((mutationsList) => {
        const targets = [...mutationsList]
          .map(getSubscribers)
          .flatMap(x => x)
        maybeCreateReactive(targets)
      }).observe(document.body, { childList: true, subtree: true });

      function sufficientlyUniqueId() {
        // https://stackoverflow.com/a/2117523
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }
    </script>
    <script>
      const $ = window.module('hello-native', { src: 'sillyz.computer' })
      $.draw(() => {
        const { src, helperActive } = $.learn()
        return `
          <div class="browser-chrome ${helperActive ? 'helper' : ''}">
            <div>
              <button class="help" aria-label="help">Â¿?</button>
            </div>
            <div class="transport">
              <input type="text" value="${src}" />
            </div>
          </div>
          <iframe src="https://${src}" title=":)"></iframe>
        `
      })
      $.when('change', 'input', (event) => {
        const src = event.target.value
        $.teach({ src })
      })

      $.when('click', '.help', (event) => {
        $.teach({ helperActive: !$.learn().helperActive })
      })
      $.style(`
        & {
          display: block;
          height: 100%;
        }

        & button {
          background: lemonchiffon;
          width: 2rem;
          height: 2rem;
          border: none;
        }
        & .browser-chrome {
          position: fixed;
          top: 0;
          left: 0;
        }

        & .transport {
          display: none;
        }

        & .helper .transport {
          display: block;
        }
      `)
    </script>
  </body>
</html>
